/**
 * 
 * https://leetcode.com/problems/rotting-oranges/description/
 * 994. Rotting Oranges
 * 
 * You are given an m x n grid where each cell can have one of three values:
 * 
 * 0 representing an empty cell,
 * 1 representing a fresh orange, or
 * 2 representing a rotten orange.
 * Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.
 * 
 * Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.
 * 
 *  
 * 
 * Example 1:
 * 
 * 
 * Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
 * Output: 4
 * Example 2:
 * 
 * Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
 * Output: -1
 * Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
 * Example 3:
 * 
 * Input: grid = [[0,2]]
 * Output: 0
 * Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.
 *  
 * 
 * Constraints:
 * 
 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 10
 * grid[i][j] is 0, 1, or 2.
 */

function orangesRotting(grid: number[][]): number {
    const rows = grid.length
    const columns = grid[0].length
    const queue: [number, number][] = []
    let fresh = 0

    for (let row = 0; row < rows; row++) {
        for (let column = 0; column < columns; column++) {
            if (grid[row][column] === 2) {
                queue.push([row, column])
            }

            if (grid[row][column] === 1) {
                fresh++
            }
        }
    }

    let time = 0

    while (queue.length > 0) {
        let currentLevelCount = queue.length

        for (let i = 0; i < currentLevelCount; i++) {
            const [row, column] = queue.shift()!

            if (row - 1 >= 0 && grid[row - 1][column] === 1) {
                grid[row - 1][column] = 2
                queue.push([row - 1, column])
                fresh--
            }

            if (column + 1 < columns && grid[row][column + 1] === 1) {
                grid[row][column + 1] = 2
                queue.push([row, column + 1])
                fresh--
            }

            if (row + 1 < rows && grid[row + 1][column] === 1) {
                grid[row + 1][column] = 2
                queue.push([row + 1, column])
                fresh--
            }

            if (column - 1 >= 0 && grid[row][column - 1] === 1) {
                grid[row][column - 1] = 2
                queue.push([row, column - 1]) 
                fresh--
            }
        }

        if (queue.length > 0) {
            time++
        }
    }

    return fresh === 0 ? time : -1
};

console.log(orangesRotting([[2,1,1],[1,1,0],[0,1,1]])) // 4
console.log(orangesRotting([[2,1,1],[0,1,1],[1,0,1]])) // -1
console.log(orangesRotting([[0,2]])) // 0